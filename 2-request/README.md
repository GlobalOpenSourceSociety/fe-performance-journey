# 发送请求

在前一部分，我们介绍了浏览器缓存。当一个请求走过了各级前端缓存后，就会需要实际发送一个请求了。所以不要认为调用了 fetch/xhr 就一定会向后端发送请求。

> 当然，在 HTTP 缓存中，我们其实也有发送请求，或者是在 HTTP/2 Push 中，使用了之前连接中推送的资源。不过为了保证思路的连贯，我还是把「发送请求」这个章节整体放在「缓存」之后了。

发送网络请求其实可以包含很复杂的知识，你可以把计算机网络里学到的各类知识都放进来。不过，今天咱们的旅程主要是聚焦于“前端性能优化”。因此，主要会介绍一些在这个环节中，前端性能优化可能会做的事儿。

## 1. 重定向

> 避免多余重定向，使用正确语义。

重定向是一个比较常用的技术手段，例如登录场景。当然，在一些情况下，你可能进行了服务迁移而修改了原有的 URI，这时候就可以使用重定向，把访问原网址的用户重定向到新的 URI。

重定向分为 301 的永久重定向和 302 的临时重定向。建议贴合语义，例如服务迁移的情况下，使用 301 重定向。对 SEO 也会语义更好。

同时，请不要滥用重定向，因为也见过有业务在访问后重定向 3 次的情况。每次重定向都是有请求耗时，建议避免过多的重定向。

## 2. DNS 解析

> DNS 预解析。

就像我们出门去找朋友玩，一般都会和师傅说，我想去 XX 大街 XX 小区。基本没人会说，我想去东经 XX 度、北纬 XX 度（比喻可能不是很恰当）。类似，一般我们访问远程服务的时候，也不会直接使用服务的出口 IP，而是域名。所以请求里非常重要的一个环节就是域名解析。

DNS 本身是一个树状结构，所以 DNS 解析会是一个递归与迭代的过程。例如 github.com 的大致解析流程如下：

1. 先检查本地 hosts 文件中是否有映射，有则使用；
1. 查找本地 DNS 缓存，有则返回；
1. 根据配置在 TCP/IP 参数中设置 DNS 查询服务器，并向其查询，这里先称为本地 DNS；
1. 如果该服务器无法解析（没有缓存），且不需要转发，则会向根服务器请求；
1. 根服务器根据域名类型判断对应的顶级域名服务器（.com）,返回给本地 DNS，然后重复该过程，直到找到该域名；
1. 当然，如果设置了转发，本地 DNS 会将请求逐级转发，直到转发服务器返回或者也不能解析。

更详细的介绍可以看[这篇文章](https://www.zhihu.com/question/23042131)<sup>[1]</sup>。

当然，我们这里更需要了解的是：

- 首先 DNS 解析流程是可能会很长、耗时很高，所以整个 DNS 服务，包括客户端都会有缓存机制，这个作为前端不好涉入；
- 其次，在 DNS 解析上，前端还是可以通过浏览器提供的其他手段来“加速”的。

DNS Prefetch 就是浏览器提供给我们的一个 API。它是 Resource Hint 的一部分。它可以告诉浏览器：过会我就可能要去 yourwebsite.com 上下载一个资源啦，帮我先解析一下域名吧。这样之后用户点击某个按钮，触发了 yourwebsite.com 域名下的远程请求时，就略去了 DNS 解析的步骤。使用方式很简单：

```HTML
<link rel="dns-prefetch" href="//yourwebsite.com">
```

当然，浏览器并不完全保证一定会去解析域名，可能会根据当前的网络请求、负载等状态做决定。标准里也明确写了

> user agent SHOULD resolve as early as possible

## 3. 预先建立连接

我们知道，建立连接不仅需要DNS查询，还需要进行TCP协议握手，有些还会有TLS/SSL协议，这些都会导致连接的耗时。因此，使用Preconnect可以帮助你告诉浏览器：“我有一些资源会用到某个源，可以帮我预先建立连接。”

根据规范，当你使用 PreConnect 时，浏览器大致做了如下处理：

- 首先，解析 PreConnect 的URL
- 其次，根据当前link元素中的属性进行cors的设置
- 默认先将credential设为true；如果cors为Anonymous并且存在跨域，则将credential置为false
- 最后进行连接

使用 PreConnect 只需要将 rel 属性设为 `preconnect` 即可：

```HTML
<link rel="preconnect" href="//yourwebsite.com">
```

当然，你也可以设置CORS

```HTML
<link rel="preconnect" href="//yourwebsite.com" crossorigin>
```

需要注意的是，标准并没有硬性规定浏览器一定要（而是SHOULD）完成整个连接过程，浏览器可以视情况完成部分工作。

## 4. CDN

> 使用 CDN 加速静态资源。

当我们实际把网络包发向我们的目标地址时，肯定希望越快到达目的地越好（对应的，也会希望越快获得相应）。而网络传输是有极限的，同样一个北京的用户，访问北京的服务器显然要比广州快很多。同时，服务的负载也决定了响应的速度。

对于一些静态资源，我们可以通过 CDN 加速来降低耗时。

对于使用 CDN 的资源，DNS 解析会将 CDN 资源的域名解析到 CDN 服务的负载均衡器上，而负载均衡器可以通过访问信息获取用户对应的地理区域，从而通过负载均衡算法，在背后的诸多服务其中，综合选择一台地理位置近、负载低的机器对用户提供服务。例如为北京联通用户解析北京的服务器 IP。这样，用户在之后访问 CDN 资源时都是访问北京服务器，距离近。

想了解更多 CDN 的工作方式可以阅读[这篇文章](https://yq.aliyun.com/articles/577708)<sup>[2]</sup>。

---

整体的请求流程大致会如下：

![resource timing line](./img/resourcetiming.png)

在缓存没法满足我们的情况下，我们要开始真正发送请求了，这里其实设计内容非常广泛。作为前端性能优化视角，我们会关注到类似重定向、DNS 解析等问题，来加速请求。但其实这块还预留出来了一小部分 —— 服务端的处理与响应。

过去，我们可能会将前端局限在浏览器中，但是随着 NodeJS 的兴起，其实很多业务中都引入了 NodeJS 作为 BFF 层来为前端提供服务，所以这里也会来简单看看，在这一阶段可能可以做的一些优化。

---

## 扩展阅读

1. [DNS 的解析过程](https://www.zhihu.com/question/23042131)
1. [CDN 之我见：原理篇](https://yq.aliyun.com/articles/577708)
1. [Understanding Resource Timing](https://developers.google.com/web/tools/chrome-devtools/network/understanding-resource-timing)
1. [URL redirection (wikipedia)](https://en.wikipedia.org/wiki/URL_redirection)
